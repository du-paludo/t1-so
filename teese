#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>    // Para função sleep()
#include <time.h>      // Para geração de números aleatórios

// Estrutura para passar os dados do processo para a thread
typedef struct {
    int id;
    int uso;
} Processo;

// Semáforo para controlar a fila FIFO
sem_t fila;

// Função que representa o comportamento do processo
void *executaProcesso(void *arg) {
    Processo *p = (Processo *)arg;
    int s;
    
    for (p->uso = 0; p->uso < 3; p->uso++) {
        // (A) Prologo
        s = rand() % 4;  // Sorteia um inteiro entre 0 e 3
        printf("Processo: %d Prologo: %d de %d segundos\n", p->id, p->uso, s);
        sleep(s);

        // Entra na fila de espera FIFO
        sem_wait(&fila);

        // (B) Uso do recurso com exclusividade
        s = rand() % 4;  // Sorteia um inteiro entre 0 e 3
        printf("Processo: %d USO: %d por %d segundos\n", p->id, p->uso, s);
        sleep(s);

        // Sai do uso e libera o próximo da fila
        sem_post(&fila);

        // (C) Epilogo
        s = rand() % 4;  // Sorteia um inteiro entre 0 e 3
        printf("Processo: %d Epilogo: %d de %d segundos\n", p->id, p->uso, s);
        sleep(s);
    }
    
    pthread_exit(NULL);
}

int main() {
    int num_processos = 5;  // Exemplo de 5 processos (pode ser alterado)
    pthread_t threads[num_processos];
    Processo processos[num_processos];

    srand(time(NULL));  // Inicializa a semente para números aleatórios

    // Inicializa o semáforo da fila com valor 1, permitindo um processo por vez
    sem_init(&fila, 0, 1);

    // Cria e inicia os processos
    for (int i = 0; i < num_processos; i++) {
        processos[i].id = i;
        pthread_create(&threads[i], NULL, executaProcesso, &processos[i]);
    }

    // Aguarda todos os processos terminarem
    for (int i = 0; i < num_processos; i++) {
        pthread_join(threads[i], NULL);
    }

    // Destrói o semáforo
    sem_destroy(&fila);

    return 0;
}



#include <iostream>
#include <thread>
#include <barrier>
#include <vector>

// Barreira que sincroniza 5 threads (ou processos)
std::barrier sync_point(5); 

void tarefa(int id) {
    std::cout << "Processo " << id << " inicia a fase 1\n";
    // Cálculos e operações da fase 1...
    sync_point.arrive_and_wait(); // Todos aguardam na barreira aqui

    std::cout << "Processo " << id << " inicia a fase 2\n";
    // Cálculos e operações da fase 2...
    sync_point.arrive_and_wait(); // Todos aguardam na próxima barreira

    std::cout << "Processo " << id << " inicia a fase 3\n";
    // Cálculos e operações da fase 3...
}

int main() {
    std::vector<std::thread> processos;
    for (int i = 0; i < 5; ++i)
        processos.emplace_back(tarefa, i);

    for (auto& p : processos)
        p.join();
}
